#CPP

# Explanation
## reinterpret_cast 는 static_cast와 달리. const_cast 처럼 컴파일시에 CPU 명령어로 변환되지 않는다. (단, 정수와 포인터 사이, 또는 특정 아키텍쳐에서 포인터의 표현이 그 타입에 따라 달라질 때는 제외)
- 주로 컴파일 시간 지시어로서, 컴파일러에게 *expression* 을 *target-type* 으로 취급하도록 지시한다.
> *reinterpret_cast* 가 실행 시간에 어떠한 실제 처리를 수행하지 않는다는 것을 의미한다. 즉, *reinterpret_cast* 는 메모리에 저장된 데이터의 바이트를 재해석하는 방법을 컴파일러에 지시하는 컴파일 시간의 연산이다.

1. **메모리 재해석** : *reinterpret_cast* 는 주어진 데이터의 메모리 표현을 변경하지 않는다. 대신, 해당 데이터를 다른 타입으로 해석하라고 컴파일러에 지시한다.
   예를 들어, *int* 포인터를 *char* 포인터로 *reinterpret_cast* 하는 경우, 메모리의 원본 바이트는 그대로 유지되지만 그 바이트들은 *char* 배열로 해석된다.
2. **타입 체크 무시** : *reinterpret_cast* 는 타입 체크를 수행하지 않는다. 즉, 어떤 타입이든 다른 타입으로 강제로 변환할 수 있다. *이는 매우 강력하지만 위험한 작업이며, 프로그래머가 타입 안정성을 직접 관리해야 한다.*
3. **런타임 오버헤드 없음** : *reinterpret_cast* 는 런타임에 어떠한 추가적인 계산이나 데이터 처리를 수행하지 않는다. 따라서 이 연산자를 사용하는 코드는 실행 시간에 추가적인 CPU 명령어를 발생시키지 않는다. 이는 *reinterpret_cast* 가 단순히 컴파일러에게 데이터의 다른 해석 방식을 알려주는 역할을 한다는 것을 의미한다.

- 다음과 같은 변환이 *reinterpret_cast* 를 사용하여 수행될 수 있습니다. 단, 이러한 변환이 *상수성(constness) 또는 변동성(volatility)* 을 없애는 경우는 제외합니다.

### 1. 정수, 열거, 포인터 또는 멤버-포인터 타입의 표현식은 자신의 타입으로 변환될 수 있습니다. 결과값은 표현식의 값과 동일하다.

