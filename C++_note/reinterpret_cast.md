#CPP

# Explanation
## reinterpret_cast 는 static_cast와 달리. const_cast 처럼 컴파일시에 CPU 명령어로 변환되지 않는다. (단, 정수와 포인터 사이, 또는 특정 아키텍쳐에서 포인터의 표현이 그 타입에 따라 달라질 때는 제외)
- 주로 컴파일 시간 지시어로서, 컴파일러에게 *expression* 을 *target-type* 으로 취급하도록 지시한다.
> *reinterpret_cast* 가 실행 시간에 어떠한 실제 처리를 수행하지 않는다는 것을 의미한다. 즉, *reinterpret_cast* 는 메모리에 저장된 데이터의 바이트를 재해석하는 방법을 컴파일러에 지시하는 컴파일 시간의 연산이다.

1. **메모리 재해석** : *reinterpret_cast* 는 주어진 데이터의 메모리 표현을 변경하지 않는다. 대신, 해당 데이터를 다른 타입으로 해석하라고 컴파일러에 지시한다.
   예를 들어, *int* 포인터를 *char* 포인터로 *reinterpret_cast* 하는 경우, 메모리의 원본 바이트는 그대로 유지되지만 그 바이트들은 *char* 배열로 해석된다.
2. **타입 체크 무시** : *reinterpret_cast* 는 타입 체크를 수행하지 않는다. 즉, 어떤 타입이든 다른 타입으로 강제로 변환할 수 있다. *이는 매우 강력하지만 위험한 작업이며, 프로그래머가 타입 안정성을 직접 관리해야 한다.*
3. **런타임 오버헤드 없음** : *reinterpret_cast* 는 런타임에 어떠한 추가적인 계산이나 데이터 처리를 수행하지 않는다. 따라서 이 연산자를 사용하는 코드는 실행 시간에 추가적인 CPU 명령어를 발생시키지 않는다. 이는 *reinterpret_cast* 가 단순히 컴파일러에게 데이터의 다른 해석 방식을 알려주는 역할을 한다는 것을 의미한다.

다음과 같은 변환이 *reinterpret_cast* 를 사용하여 수행될 수 있습니다. 단, 이러한 변환이 *상수성(constness) 또는 변동성(volatility)* 을 없애는 경우는 제외합니다.

1. 정수, 열거, 포인터 또는 멤버-포인터 타입의 표현식은 자신의 타입으로 변환될 수 있습니다. 결과값은 표현식의 값과 동일하다.
2. 포인터는 그 타입의 모든 값을 담을 수 있는 충분한 크기의 정수 타입(예: `std::uintptr_t`)으로 변환될 수 있다.
3. 모든 정수 또는 열거 타입의 값은 포인터 타입으로 변환될 수 있다. 충분한 크기의 정수로 변환된 포인터를 동일한 포인터 타입으로 다시 변환하면 원래 값이 보장되지만, 그렇지 않으면 결과 포인터는 안전하게 역참조될 수 없다(반대 방향의 라운드트립 변환은 보장되지 않음; 동일한 포인터에 대해 여러 정수 표현이 있을 수 있음). 널 포인터 상수 `NULL` 또는 정수 0은 타겟 타입의 널 포인터 값이 보장되지 않으므로, 이 목적을 위해서는 `static_cast` 또는 암시적 변환을 사용해야 한다.
4. `std::nullptr_t` 타입의 모든 값, `nullptr` 포함,은 마치 `(void*)0`인 것처럼 모든 정수 타입으로 변환될 수 있지만, `nullptr`을 포함한 어떤 값도 `std::nullptr_t`로 변환될 수 없다: 이 목적을 위해서는 `static_cast`를 사용해야 한다.
5. 어떤 객체 포인터 타입 `T1*`은 다른 객체 포인터 타입 `cv T2*`로 변환될 수 있습니다. 이것은 `static_cast<cv T2*>(static_cast<cv void*>(expression))`과 정확히 동일합니다(이는 `T2`의 정렬 요구 사항이 `T1`보다 엄격하지 않다면 포인터의 값이 변하지 않고 원래 타입으로의 포인터 변환으로 원래 값이 복원된다는 것을 의미함). 어떤 경우에도 결과 포인터는 타입 별칭 규칙에 의해 허용되는 경우에만 안전하게 역참조될 수 있습니다.
6. `T1` 타입의 lvalue(후 C++11)glvalue(이후 C++11) 표현식은 다른 타입 `T2`의 참조로 변환될 수 있습니다. 결과는 `*reinterpret_cast<T2*>(p)`와 동일하며, 여기서 `p`는 표현식을 지정하는 객체에 대한 “T1 포인터 타입”의 포인터입니다. 임시 객체는 생성되지 않으며, 복사도 이루어지지 않고, 생성자나 변환 함수도 호출되지 않습니다. 결과 참조는 타입 별칭 규칙에 의해 허용되는 경우에만 안전하게 접근될 수 있습니다.
7. 함수 포인터는 다른 함수 타입의 포인터로 변환될 수 있습니다. 다른 함수 타입의 포인터를 통해 함수를 호출하는 것은 정의되지 않았지만, 해당 포인터를 원래 함수 타입의 포인터로 변환하면 원래 함수의 포인터가 반환됩니다.
8. 일부 구현(특히, `dlsym`에 의해 요구되는 모든 POSIX 호환 시스템에서)에서는 함수 포인터를 `void*` 또는 다른 객체 포인터로 변환할 수 있으며, 그 반대의 경우도 마찬가지입니다. 구현이 양방향 변환을 지원하는 경우, 원래 타입으로의 변환은 원래 값이 보장되지만, 그렇지 않으면 결과 포인터는 안전하게 역참조되거나 호출될 수 없습니다.
9. 어떤 포인터 타입의 널 포인터 값은 다른 포인터 타입으로 변환될 수 있으며, 그 결과는 해당 타입의 널 포인터 값입니다. 널 포인터 상수 `nullptr` 또는 `std::nullptr_t` 타입의 다른 값은 `reinterpret_cast`를 사용하여 포인터로 변환될 수 없습니다: 이 목적을 위해서는 암시적 변환 또는 `static_cast`를 사용해야 합니다.
10. 멤버 함수의 포인터는 다른 타입의 다른 멤버 함수의 포인터로 변환될 수 있습니다. 원래 타입으로 변환하면 원래 값이 복원됩니다. 그렇지 않으면 결과 포인터는 안전하게 사용될 수 없습니다.
11. 어떤 클래스 `T1`의 멤버 객체에 대한 포인터는 다른 클래스 `T2`의 다른 멤버 객체에 대한 포인터로 변환될 수 있습니다. `T2`의 정렬이 `T1`보다 엄격하지 않다면 원래 타입 `T1`으로 변환하면 원래 값이 복원됩니다. 그렇지 않으면 결과 포인터는 안전하게 사용될 수 없습니다.