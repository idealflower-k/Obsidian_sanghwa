### 템플릿의 종류:

C++98에서는 주로 두 가지 타입의 템플릿을 사용합니다:

1. **함수 템플릿**: 같은 로직을 다양한 타입에 적용할 수 있게 해주는 함수입니다.
2. **클래스 템플릿**: 구조나 동작이 유사하지만 다른 타입을 다루는 클래스를 정의할 때 사용됩니다.

### 함수 템플릿:

함수 템플릿은 함수를 정의할 때 특정 타입 대신 템플릿 매개변수를 사용합니다. 예를 들어, 두 값을 교환하는 함수 템플릿은 다음과 같습니다:

```cpp
template <typename T>
void swap(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}
```

여기서 `typename T`는 템플릿 매개변수로, 함수가 호출될 때 어떤 타입이든 될 수 있습니다.

### 클래스 템플릿:

클래스 템플릿은 데이터 구조나 클래스가 다양한 타입에 대해 동작할 수 있도록 합니다. 예를 들어, 간단한 배열 클래스 템플릿은 다음과 같이 정의할 수 있습니다:

```cpp
template <typename T>
class Array {
private:
    T* array;
    size_t size;
public:
    // 생성자, 소멸자, 필요한 메서드들...
};
```

여기서 `typename T`는 클래스가 다룰 데이터 타입을 나타냅니다.

### 템플릿의 인스턴스화:

- 컴파일러는 템플릿을 사용하는 코드를 만나면 템플릿의 "인스턴스화"를 수행합니다. 이는 템플릿 코드에서 실제 타입을 사용하는 구체적인 코드를 생성하는 과정입니다.
- 예를 들어, `swap<int>(a, b)` 또는 `Array<double>`와 같이 템플릿을 호출하면, 컴파일러는 각각 `int`와 `double`을 사용하는 `swap` 함수와 `Array` 클래스의 인스턴스를 생성합니다.

### 특수화:

템플릿 특수화는 특정 타입에 대해 다른 동작이나 구현을 제공할 때 사용됩니다. 전체 특수화와 부분 특수화가 있으며, 특정 타입에 대한 템플릿의 동작을 오버라이드합니다.

### 주의사항:

- **컴파일 시간**: 템플릿은 컴파일 시간에 처리되므로, 템플릿 코드는 컴파일 시간에 타입이 결정될 수 있어야 합니다.
- **타입 안전성**: 템플릿을 사용할 때는 타입 안전성을 고려해야 합니다. 템플릿 매개변수로 주어진 타입이 템플릿의 모든 연산에 적합한지 확인해야 합니다.

C++98 표준에서 템플릿은

 C++의 타입 안전성, 재사용성, 유연성을 크게 향상시킨 중요한 기능으로, 현대 C++ 프로그래밍의 기초를 형성합니다.