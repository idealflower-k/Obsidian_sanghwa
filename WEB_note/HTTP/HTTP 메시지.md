#HTTP 
# 3. HTTP 메시지
- HTTP 메시지는 무언가를 담아 보내는 소포와 같다.
## 3.1 메시지의 흐름
- HTTP 애플리케이션 간에 주고받은 데이터의 블록들이다.
- 클라이언트, 서버, 프록시 사이를 흐른다.
- '인바운드', '아웃바운드', '업스트림', '다운스트림'은 메시지의 방향을 의미하는 용어다.
### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다.
- HTTP는 인바운드, 아웃바운드라는 용어를 **트랜잭션 방향**을 표현하기 위해 사용한다.
- **인바운드** : 메시지가 원 서버로 향하는 것은 인바운드로 이동하는 것
- **아웃바운드** : 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것은 아웃바운드로 이동하는 것
### 3.1.2 다운스트림으로 흐르는 메시지
- 모든 메시지는 다운스트림으로 흐른다.
- **업스트림** : 메시지의 발송자
## 3.2 메시지의 각 부분
- HTTP 메시지는 단순한, 데이터의 구조화된 블록이다.
- **시작줄** : 이것이 어떤 메시지인지 서술
- **헤더블록** : 속성을 서술
- **본문(선택사항)** : 데이터를 담고 있다.
- 시작줄과 헤더는 줄 단위로 분리된 아스키 문자열이다.
- 각 줄은 캐리지 리턴(ASCII 13)과 개행 문자(ASCII 10)로 구성된 두 글자의 줄바꿈 문자열로 끝난다. 이 줄바꿈 문자열은 **'CRLF'** 라고 쓴다.
- HTTP 명세에 따른다면 줄바꿈 문자열은 CRLF이지만 견고한 애플리케이션이라면 그냥 개행 문자도 받아들일 수 있어야 한다.
- **본문**은 텍스트나 이진 데이터를 포함할 수도 있고 그냥 비어있을 수도 있다.
- **헤더**는 본문에 대한 많은 정보를 준다.
	- **Content-Type**: 본문이 무엇인지 말해준다.
	- **Content-Length**: 본문의 크기를 말해준다. 
### 3.2.1 메시지 문법
- **요청 메시지** : 웹 서버에 어떤 동작을 요구한다.
```text
<메서드> <요청 URL> <버전>
<헤더>

<엔터티 본문>
```
- **응답 메시지** : 요청의 결과를 클라이언트에게 돌려준다.
```text
<버전> <상태 코드> <사유 구절>
<헤더>

<엔터티 본문>
```
#### 메서드
- 클라리언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작
- 'GET', 'HEAD', 'POST'와 같이 한 단어로 되어 있다.
#### 요청 URL
- 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성요소이다.
- 완전한 URL이 아닌 URL의 경로 구성요소라고 해도, 클라이언트가 서버와 직접 대화하고 있고 경로 구서요소가 리소스를 카리키는 절대 경로이기만 하면 대체로 문제가 없다.
#### 버전
- 메시지에서 사용 중인 HTTP의 버전이다.
> HTTP/<메이저>.<마이너>
> 메이저와 마이너는 모두 정수다.
#### 사유 구절 (reason-phrase)
- 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구
- 상태 코드 이후부터 줄바꿈 문자열까지가 사유 구절이다.
- 오로지 사람에게 읽히기 위한 목적으로만 존재하는 것이다.
#### 헤더들
- 이름, 콜론(:), 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들
- 이 헤더의 목록은 빈 줄(CRLF)로 끝나 헤더 목록의 끝과 엔터티 본문의 시작을 표시한다.
- HTTP/1.1과 같은 몇몇 버전의 HTTP는 요청이나 응답에 어떤 특정 헤더가 포함 되어야만 유효한 것으로 간주한다.
#### 엔터티 본문
- 임의의 데이터 블록을 포함한다.
- 때떄로 메시지는 그냥 CRLF으로 끝나게 된다.
![[image file/File (3).jpg]]
- 헤더나 엔터티 본문이 없더라도 HTTP 헤더의 집합은 항상 빈 줄(그냥 CRLF)로 끝나야 함에 주의하라.
- 규칙을 지키지 않는 구현체와의 호환을 위해, 클라이언트와 서버는 마지막에 CRLF 없이 끝나는 메시지도 받아들일 수 있어야 한다.
### 3.2.2 시작줄
- 모든 HTTP 메시지는 시작줄로 시작한다.
#### 요청줄 (요청 메시지의 시작줄)
- 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메서드와 그 동작에 대한 대상을 지칭하는 요청 URL이 들어있다.
- 클라이언트가 어떤 HTTP 버전으로 말하고 있는지 서버에게 알려주는 HTTP 버전도 포함한다.
- 이 모든 필드는 공백으로 구분된다.
#### 응답줄 (응답 메시지의 시작줄)
- 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다.
- 응답 메시지에서 쓰인 HTTP의 버전, 숫자로 된 상태 코드, 수행 상태에 대해 설명해주는 텍스트로 된 사유 구절이 들어 있다.
- 이 모든 필드는 공백으로 구분된다.
#### 메서드
- 요청의 시작줄은 메서드로 시작하며, 서버에게 무엇을 해야 하는지 말해준다.
- HTTP 명세는 공통 요청 메서드의 집합을 정의한다.

| 메서드  | 설명                                                    | 메시지 본뭉이 있는가? |
| ------- | ------------------------------------------------------- | --------------------- |
| GET     | 서버에서 어떤 문서를 가져온다.                          | 없음                  |
| HEAD    | 서버에서 어떤 문서에 대해 헤더만 가져온다.              | 없음                  |
| POST    | 서버가 처리해야 할 데이터를 보낸다.                     | 있음                  |
| PUT     | 서버에 요청 메시지의 본문을 저장한다.                   | 있음                  |
| TRACE   | 메시지가 프록시를 거쳐 서버에 도달하는 과정을 추적한다. | 없음                  |
| OPTIONS | 서버가 어떤 메서드를 수행할 수 있는지 확인한다.         | 없음                  |
| DELETE  | 서버에서 문서를 제거한다.                               | 없음                      |

#### 상태 코드
- 클라이언트에게 무엇이 일어났는지 말해준다.
- 응답의 시작줄에 위치한다.

| 전체범위  | 정의된 범위 | 분류            |
| --------- | ----------- | --------------- |
| 100 ~ 199 | 100 ~ 101   | 정보            |
| 200 ~ 299 | 200 ~ 206   | 성공            |
| 300 ~ 399 | 300 ~ 305   | 리다이렉션      |
| 400 ~ 499 | 400 ~ 415   | 클라이언트 에러 |
| 500 ~ 599 | 500 ~ 505   | 서버 에러                |

- 흔한 상태 코드 중 몇 가지

| 상태 코드 | 사유 구절    | 의미                                    |
| --------- | ------------ | --------------------------------------- |
| 200       | OK           | 성공!                                   |
| 401       | Unauthorized | 사용자 이름과 비밀번호를 입력해야 한다. |
| 404       | Not Found    | 서버는 요청한 URL에 해당하는 리소스를 찾지 못했다.                                        |

#### 사유 구절
- 응답 시작줄의 마지막 구성요소
- 상테 코드에 대한 클로 된 설명을 제공한다.
#### 버전 번호
- HTTP/x.y 형식으로 요청과 응답 메시지 양쪽 모두에 기술된다.
- 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단이 된다.
- 응답의 프로토콜 버전이 HTTP/1.1이라는 것은 사실 응답을 보낸 애플리케이션이 HTTP/1.1까지 이해할 수 있음을 의미하는 것이다.
### 헤더
- 시작줄 다음에는 0개, 1개  혹은 여러 개의 HTTP 헤더가 온다.
- HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더한다.
- 기본적으로 이름/값 쌍의 목록이다.
#### 헤더 분류
- HTTP 헤더 명세는 여러 헤더 필드를 정의한다.
##### 일반 헤더
- 요청과 응답 양쪽에 모두 나타날 수 있음
##### 요청 헤더
- 요청에 대한 부가 정보를 제공
##### 응답 헤더
- 응답에 대한 부가 정보를 제공
##### Entity 헤더
- 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
##### 확장 헤더
- 명세에 정의되지 않은 새로운 헤더

- 각 HTTP 헤더는 간단한 문법을 가진다. 이름, 쉼표, 공백(없어도 된다), 필드 값, CRLF가 순서대로 온다.

| 헤더의 예                          | 설명                                       |
| ---------------------------------- | ------------------------------------------ |
| Date: Tue, 3 Oct 1997 02:16:03 GMT | 서버가 응답을 만들어 낸 시각               |
| Content-length: 15040              | 15,040바이트의 데이터를 포함한 엔터티 본문 |
| Content-type: image/gif            | 엔터티 본문은 GIF 이미지다.                |
| Accept: image/gif, image/jpeg, text/html                                   | 클라이언트는 GIF, JPEG 이미지와 HTML을 받아들일 수 있다.                                           |
##### 헤더를 여러 줄로 나누기
- 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭 문자가 와야 한다.
### 3.2.4 엔터티 본문
- 선택적인 엔터티 본문이다.
- HTTP 메시지의 화물이라고 할 수 있다.
- 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 여러 종류의 디지털 데이터를 실어 나를 수 있다.
## 3.3 메서드
- 모든 서버가 모든 메서드를 구현하지는 않는다.
### 3.3.1 안전한 메서드 (safe Method)
- GET과 HEAD 메서드는 안전하다고 할 수 있다. 이는 HTTP 요청의 결과로 서버에 어떤 작용도 없음을 의미한다.
- 안전한 메서드가 서버에 작용을 유발하지 않는다는 보장은 없다. (웹 개발자에게 달려있다.)
- **목적**은 안전하지 않은 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP 애플리케이션을 만들 수 있도록 하는 것에 있다.
### 3.3.2 GET
- 가장 흔히 쓰이는 메서드다.
- 서버에게 리소스를 달라고 요청하기 위해 쓰인다.
- HTTP/1.1은 서버가 이 메서드를 구현할 것을 요구한다.
### 3.3.3 HEAD
- HEAD 메서드는 정확히 GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려준다. **엔터티 본문은 결코 반환되지 않는다.**
- 클라이언트가 리소스르 ㄹ실제로 가져올 필요 없이 헤더만을 조사할 수 있도록 해준다.
- 리소스를 가져오지 않고도 그에 대해 무엇인가(타입리라거나)를 알아낼 수 있다.
- HEAD를 사용하면,
	- 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
	- 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.
- 서버 개발자들은 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야 한다.
- HTTP/1.1 준수를 위해서는 HEAD 메서드가 반드시 구현되어 있어야 한다.
```http
요청 메시지
HEAD /seasonal/index-fall.html HTTP/1.1
Host: www.joes-hardware.com
Accept: *

응답 메시지 (엔터티 본문 없음)
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 617
```
### 3.3.4 PUT
- PUT 메서드는 서버에 문서를 쓴다.
- 어떤 발행 시스템은 사용자가 PUT을 이용해 웹페이지를 만들고 웹 서버에 직접 게시할 수 있도록 해준다.
- 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것이다.
- PUT은 콘텐츠를 변경할 수 있게 해주기 때문에, 많은 웹 서버가 PUT을 수행하기 전에 사용자에게 비밀번호를 입력해서 로그인을 하도록 요구할 것이다.
### 3.3.5 POST
- 서버에 입력 데이터를 전송하기 위해 설계되었다.
- 채워진 폼에 담긴 데이터는 서버로 전송되며, 서버는 이를 모아서 필요로 하는 곳(그 데이터를 처리할 서버 게이트웨이 프로그램)에 보낸다.
### 3.3.6 TRACE
- 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.
- 클라이언트가 어떤 요청을 할 때, 그 요청은 방화벽, 프록시, 게이트웨이 등의 애플리케이션을 통과할 수 있다.
- 이들에게는 원래의 HTTP 요청을 수정할 수 있는 기회가 있다.
- 목적지서버에서 루프백 진단을 시작한다.
- 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 되돌려준다.
- 클라이언트는 자신의 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가면서 자신이 보낸 메시지가 망가졌거나 수정되었는지, 만약 그렇다면 어떻게 변경되었는지 확인할 수 있다.
- 주로 진단을 위해 사용된다.
- 그 대신 중간 애플리케이션이 여러 다른 종류의 요청들을 일관되게 다룬다고 가정하는 문제가 있다.
- 많은 HTTP 애플리케이션은 메서드에 따라 다르게 동작한다.
- TRACE는 메서드를 구별하는 메커니즘을 제공하지 않는다.
- 어떻게 TRACE 요청을 처리할 것이지에 대해서는 중간 애플리케이션이 결정을 내린다.
### OPTIONS
- 웹 서버에게 여러가지 종류의 지원 범위에 대해서 물어본다.
- 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다.
- 서버는 자신의 리소스에 대해 지원하는 메서드의 목록을 반환한다.
### DELETE
- 요청한 URL로 지정한 리소스를 삭제할 것을 요청한다.
- 클라이언트는 삭제가 수행되는 것을 보장하지 못한다.
- HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문이다.
### 3.3.9 확장 메서드
- HTTP/1.1 명세에 정의되지 않은 메서드다.
- HTTP는 필요에 따라 확장해도 문제가 없도록 설계되어 있다.

| 메서드 | 설명                                                                                                                              |
| ------ | --------------------------------------------------------------------------------------------------------------------------------- |
| LOCK   | 사용자가 리소스를 잠글 수 있게 해준다. 문서를 편집하는 동안 다른 사람이 동시에 같은 문서를 편집하지 못하도록 문서를 잠글 수 있다. |
| MKCOL  | 사용자가 문서를 생성할 수 있게 해준다                                                                                             |
| COPY   | 서버에 있는 리소스를 복사한다.                                                                                                    |
| MOVE   | 서버에 있는 리소스를 옮긴다.                                                                                                      |
- 확장 메서드는 관용적인게 최고다.
- 프록시는 알려지지 않은 메서드가 담긴 메시지를 다운스트림 서버로 전달하려고 시도한다.
- "엄격하게 보내고 관대하게 받아들여라" 라는 오랜 규칙에 따르는 것이 가장 좋다.
## 3.4 상태 코드
- 클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공한다.
- 사유 구절을 정확히 어떻게 써야 하는지에 대한 가이드는 존재하지 않는다.
### 3.4.1 100~199: 정보성 상태 코드
- HTTP/1.1에서 도입

| 상테 코드 | 사유 구절           | 의미                                                                                                                                                    |
| --------- | ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 100       | Continue            | 요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지를 계속이어서 보내야 함을 의미한다. 이것을 보낸 후, 서버는 반드시 요청을 받아 응답해야 한다. |
| 101       | Switching Protocols | 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미한다.                                                                  |                                                                                                 |
- **100 Continue**는 HTTP 클라이언트 애플리케이션이 서버에 엔터티 본문을 전송하기 전에 그 엔터티 본문을 서버가 받아들일 것인지 확인하려고 할 때, 그 확인 작업을 최적화하기 위한 의도로 도입된 것이다.
### 3.4.2 200~299: 성공 상태 코드
- 서버는 대응하는 성공을 의미하는 상태 코드의 배열을 갖고 있으며, 각각 다른 종류의 요청에 대응 한다.
![[image file/성공 상태 코드.jpeg]]
### 3.4.3 300~399: 리다이렉션 상태 코드
- 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공한다.
- 리다이렉션 상태 코드 중 몇몇은 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용된다.
- 일반적으로, HEAD가 아닌 요청에 대해 리다이렉션 상태 코드를 포함한 응답을 할 때, 리다이렉트될 URL에 대한 링크와 설명을 포함시키는 것은 좋은 습관이다.
- p.72 표 3-8 참조
- 서버는 리다이렉트 응답에 들어갈 가장 적절한 리다이렉트 상태 코드를 선택하기 위해 클라이언트의 HTTP 버전을 검사할 필요가 있다.
### 3.4.4 400~499: 클라이언트 에러 상태 코드
- 가끔 클라이언트는 서버가 다룰 수 없는 무엇인가를 보낸다.
- 많은 클라이언트 에러가 당신을 귀찮게 하지 않고 브라우저에 의해 처리된다.
- p.75 표 3-9 참조
### 3.4.5 500~599: 서버 에러 상태 코드
- 서버 자체에서 에러가 발생하는 경우가 있다.
- 클라이언트가 서버의 제한에 걸린 것일 수도 있고 혹은 게이트웨이 리소스와 같은 서버의 보조 구성요소에서 발생한 에러일 수 도 있다.
- 프록시는 클라이언트의 입장에서 서버와 대화를 시도할 때 자주 에러를 만나게 된다.
![[image file/서버 에러 상테 코드.jpeg]]
## 3.5 헤더
- 헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용된다.
- 특정 종류의 메시지에만 사용할 수 있는 헤더
- 일반 목적으로 사용할 수 있는 헤더
- 응답과 요청 메시지 양쪽 모두에서 정보를 제공하는 헤더
- 크게 5가지
### 3.5.1 일반 헤더 (General Headers)
- 메시지에 대한 아주 기본적인 정보를 제공한다.
![[image file/일반 헤더.jpeg]]
- **일반 캐시 헤더**
	- 매번 원 서버로부터 객ㅊ체를 가져오는 대신 로컬 복사본으로 캐시할 수 있도록 해주는 헤더를 도입했다.
	- 기본적인 캐시 헤더

| 헤더          | 설명                                                                  |
| ------------- | --------------------------------------------------------------------- |
| Cache-Control | 메시지와 함께 캐기 지시자를 전달하기 위해 사용한다.                   |
| Pragma        | 메시지와 함께 지시자를 전달하는 또 다른 방법. 캐시에 국한되지 않는다. |
### 3.5.2 요청 헤더
- 요청 메시지에서만 의미를 갖는 헤더
- 요청이 최초로 발생한 곳에서 누가 혹은 무엇이 요청을 보냈는지에 대한 정보, 클라이언트의 선호나 능력에 대한 정보
- 서버는 더 나은 응답을 주기 위해 활용할 수 있다.
![[image file/요청 정보 헤더.jpeg]]
