---
tags:
  - kernel
  - CS
---
# What is kernel queue?
Kernel event queue = KQ

- KQ는 서버 소프트웨어가 매우 효과적인 방식으로 OS의 이벤트를 처리할 수 있도록 하는 빠른 신호 전달 메커니즘

- KQ는 커널 메모리에 존재하는 일련의 데이터와 이 데이터를 조작하여 다양한 시스템 이벤트에 대해 사용자 수준의 애플리케이션에 알림을 제공하는 일련의 커널 코드로 구성되어 있다.

- 사용자 앱은 KQ 데이터에 직접 액세스할 수 없으므로(커널에 의해 관리됨) OS가 제공하는 API를 통해 KQ와 함께 작동한다. (kqueue, epoll...)

- KQ의 주요 목적은 네트워크 소켓에서 알림을 전달하는 것

## use-case N1
- 애플리케이션이 KQ 기술을 통해 얻을 수 있는 것은 네트워크 패킷이 수신될 때와 같은 I/O 신호에 대해 알림을 받는 것이다.

0. 어떤 사용자 앱이 UDP 소켓을 생성하고 앱 정의 데이터(예: 쿠키)와 함께 KQ에 등록했다고 가정해 보겠습니다.
1. 어느 시점에 네트워크 디바이스에서 UDP 패킷의 마지막 청크를 수신합니다.
2. 이제 OS는 완전한 UDP 패킷을 확보하고 KQ 대기 함수를 호출하는 즉시 사용자 프로세스에 알릴 준비가 되었습니다.
3. 어느 시점에 사용자 앱은 커널에 이를 알리는 KQ 대기 함수를 호출합니다: 새로운 것을 주세요.
4. OS는 쿠키와 연결된 소켓에서 Got a READ 이벤트로 응답합니다.
5. 이 쿠키는 앱이 신호를 처리하는 데 사용하는 객체 포인터로, 이 경우 UDP 소켓에서 메시지를 읽습니다.

## use-case N2
- 사용자 앱이 TCP 소켓이 peer에 연결한 후 알림을 수신하는 예제

0. 사용자 앱은 TCP 소켓을 생성하고 일부 앱 정의 데이터(예: 쿠키)와 함께 KQ에 등록합니다.
1. 이제 앱이 원격 호스트에 연결하기 위한 절차를 시작합니다. 물론 이 작업은 TCP 연결에 필요한 2개의 TCP 패킷을 전송하는 데 시간이 걸리기 때문에 대부분의 경우 즉시 완료될 수 없습니다. 게다가 네트워크 링크가 매우 바빠서 패킷이 끊어지면 어떻게 될까요? TCP 연결이 완료되는 데 시간이 오래 걸릴 수 있다는 것은 말할 필요도 없습니다. 이 때문에 OS는 즉시 작업을 완료할 수 없다는 결과와 함께 제어권을 앱에 반환합니다. 패킷이 송수신되는 동안 앱은 다른 작업을 계속 수행하면서 OS에 의존하여 연결 절차를 완료하기 위해 최선을 다합니다.
2. 마침내 원격 호스트에서 SYN+ACK TCP 패킷이 수신되며, 이는 원격 호스트가 앱과 TCP 연결을 설정할 의향이 있음을 의미합니다. 이제 OS는 앱이 준비되는 즉시 앱에 신호를 보낼 준비가 되었습니다.
3. 어느 시점에서 사용자 앱은 커널에 이를 알리는 KQ 대기 함수를 호출합니다: 새로운 것을 보여주세요.
4. OS는 쿠키와 연결된 소켓에서 WRITE 이벤트가 발생했다고 응답합니다.
5. 이 쿠키는 앱이 신호를 처리하는 데 사용하는 객체 포인터로, 이 경우 TCP 소켓에 일부 데이터를 씁니다.
## Internal representation example
![[image file/스크린샷 2023-09-20 22.49.30.png]]
- 시그널 플래그는 사용자 앱이 함수를 호출하여 KQ로부터 이벤트를 수신한 후 이 세 가지 시그널 이벤트의 배열을 수신하여 처리할 수 있다는 것을 의미한다.
- 그런 다음 커널은 필요한 경우가 아니면 동일한 신호를 반복해서 전달하지 않도록 시그널링된 플래그를 지울 수 있습니다